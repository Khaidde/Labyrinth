<html lang="en-US">
<head>
	<title>Labyrinth</title>
  	<script id=socket src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"> </script>
    <script src="https://jeremyckahn.github.io/keydrown/dist/keydrown.min.js"> </script>
</head>
<body style="background-color:black" oncontextmenu="return false;">
	<script>
        document.body.style.marginTop = 0;
        document.body.style.marginLeft = 0;
        document.body.style.marginBottom = 0;
        document.body.style.marginUp = 0;
        size = 8;
        length = 1000;
        
        var camera, scene, renderer, map; //, geometry, material, mesh;
        var canvasW, canvasH;
        var mouseMove;
        var xpos = 0;
        var ypos = 400;
        var zpos = 0;
        var speed = 20;
        var rot_y = 0;
        var rot_x = 0;
        var rot_z = 0;
        var testMap = create2Darr(size);
        
        class mapBlock{
            constructor(l, r, t, b, x, y, alt){
                this.left = l;
                this.right = r;
                this.top = t;
                this.bottom = b;
                this.centerX = x;
                this.centerY = alt;
                this.centerZ = y;
            }
            create(){
                var geomTile = new THREE. BoxBufferGeometry(length,10,length);
                
                var boxMatF = new THREE.MeshPhongMaterial();
                var boxMatC = new THREE.MeshPhongMaterial();
                var boxMatW = new THREE.MeshPhongMaterial({color: 0x444444});
                
                var meshF = new THREE.Mesh(geomTile, boxMatF);                
                meshF.material.color.setHex(0x650000);
                
                meshF.receiveShadow = true; //default
//                meshC.material.color.setHex(0x555555);
                meshF.position.set(this.centerX, this.centerY, this.centerZ);
//                meshC.position.set(this.centerX, this.centerY+length, this.centerZ);
                
                if(this.left){
                    var meshL = new THREE.Mesh(geomTile, boxMatW);
                    meshL.castShadow = true;
                    meshL.receiveShadow = true;
                    meshL.position.set(this.centerX - length/2,this.centerY+length/2, this.centerZ);
                    meshL.rotation.z = 90*Math.PI/180;
                    scene.add(meshL);
                }
                if(this.right){
                    var meshR = new THREE.Mesh(geomTile, boxMatW);
                    meshR.castShadow = true;
                    meshR.receiveShadow = true;
                    meshR.position.set(this.centerX + length/2,this.centerY+length/2, this.centerZ);
                    meshR.rotation.z = 90*Math.PI/180;
                    scene.add(meshR);
                }
                if(this.top){
                    var meshT = new THREE.Mesh(geomTile, boxMatW);
                    meshT.castShadow = true;
                    meshT.receiveShadow = true;
                    meshT.position.set(this.centerX,this.centerY+length/2, this.centerZ-length/2);
                    meshT.rotation.x = 90*Math.PI/180;
                    scene.add(meshT);
                }
                if(this.bottom){
                    var meshB = new THREE.Mesh(geomTile, boxMatW);
                    meshB.castShadow = true;
                    meshB.receiveShadow = true;
                    meshB.position.set(this.centerX,this.centerY+length/2, this.centerZ+length/2);
                    meshB.rotation.x = 90*Math.PI/180;
                    scene.add(meshB);
                }
                scene.add(meshF);
//                scene.add(meshC);
            }
        }
        
        init();
        animate();
        
        function getMap(){
            // mostly will be given to me by calvin later
            map = create2Darr(size);
            map[0][0] = 10;
            map[0][1] = 10;
            map[0][2] = 10;
            map[0][3] = 10;
            map[1][0] = 10;
            map[1][1] = 10;
            map[1][2] = false; // implies no map block present
            map[1][3] = 10;
            map[2][0] = false;
            map[2][1] = 10;
            map[2][2] = false;
            map[2][3] = 10;
            map[3][0] = false;
            map[3][1] = 10;
            map[3][2] = 10;
            map[3][3] = 10;
            
            map[4][0] = false;
            map[4][1] = 10;
            map[4][2] = 10;
            map[4][3] = 10;
            map[5][0] = 10;
            map[5][1] = 10;
            map[5][2] = false; // implies no map block present
            map[5][3] = 10;
            map[6][0] = false;
            map[6][1] = 10;
            map[6][2] = false;
            map[6][3] = 10;
            map[7][0] = false;
            map[7][1] = 10;
            map[7][2] = 10;
            map[7][3] = 10;
        }
        function interpretMap(){
            getMap();
            for(var i=0;i<map.length;i++){
                for(var j=0;j<map[i].length;j++){
                    var l, r, t, b;
                    
                    if(map[i][j] == false)
                        continue;
                    // check some stuff
                    
                    if(i == 0){
                        t = true;
                        b = !(map[i+1][j]);
                    }
                    else if (i == map.length-1){
                        t = !(map[i-1][j]);
                        b = true;
                    }
                    else{
                        t = !(map[i-1][j]);
                        b = !(map[i+1][j]);
                    }
                    
                    
                    if(j == 0){
                        l = true;
                        r = !(map[i][j+1]);
                    }
                    else if (j == map[i].length-1){
                        l = !(map[i][j-1]);
                        r = true;
                    }
                    else{
                        l = !(map[i][j-1]);
                        r = !(map[i][j+1]);
                    }
                        
                    
                    // initialize map parts
                    testMap[i][j] = new mapBlock(l, r, t, b, j*length, i*length, map[i][j])
                    testMap[i][j].create()
                }
            }
        }
        
        function init() {
            // scene set up 
            scene = new THREE.Scene();
            
            lightUp();
            // camera set up 
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
            
            // sphere existence is good for testing
            testSphere();
            
            interpretMap();
            
            this.renderer = new THREE.WebGLRenderer();
            this.renderer.shadowMap.enabled = true;
            this.renderer.shadowMapSoft = true; // default THREE.PCFShadowMap

            document.body.appendChild(renderer.domElement);
            
//            document.addEventListener('mousemove', update_mouseMovement);
            kd.run(function () {
              kd.tick();
            });
        }
        function lightUp(){
            var light = new THREE.AmbientLight( 0x008080, 0.5 ); // soft white light
            scene.add( light );
            
            var pLight = new THREE.DirectionalLight( 0xffffff, 2.5 );
            pLight.decay = 2;
            pLight.position.set( 5000, 5000, 5000 );
            pLight.castShadow = true;
            pLight.shadow.bias = 0.0001;
            scene.add( pLight );
        }
        function testSphere(){
            geometry = new THREE.SphereGeometry( 600, 50, 50 );
            material = new THREE.MeshStandardMaterial( {wireframe:false} );
            mesh = new THREE.Mesh( geometry, material );
            mesh.material.color.setHex( 0xffff00 );
            mesh.castShadow = true;
            mesh.receiveShadow = false;
            mesh.position.y = 800;
            scene.add( mesh );
        
        }
        function animate() {
            requestAnimationFrame(animate);
            render();
            camera.updateProjectionMatrix()
//            console.log(mesh.castShadow)
        }
        function render() {
            renderer.setClearColor( 0x0a0806, 1);
            renderer.setPixelRatio( window.devicePixelRatio );

            update_keyboardWASD(); // jumps handled differently

            camera.position.x = xpos;
            camera.position.y = ypos;
            camera.position.z = zpos;
            
            camera.rotation.y -= Math.PI/180 * rot_x * 0.6;
//            camera.rotation.x -= Math.PI/180 * rot_y * 0.6;
//            camera.rotation.z += Math.PI/180 * rot_z * 0.6;
            rot_x = 0;
//            rot_y = 0;
//            rot_z = 0;
            
            canvasW = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            canvasH = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight
            renderer.setSize(canvasW,canvasH);
            renderer.render(scene, camera);
        }
        
        function update_keyboardWASD(){
            kd.W.down(function () {
                zpos-=speed*Math.cos(camera.rotation.y);
                xpos-=speed*Math.sin(camera.rotation.y)
            });
            kd.S.down(function(){
                zpos+=speed*Math.cos(camera.rotation.y); 
                xpos+=speed*Math.sin(camera.rotation.y)
            });
            kd.A.down(function(){
                xpos-=speed*Math.cos(camera.rotation.y); 
                zpos+=speed*Math.sin(camera.rotation.y)
            });
            kd.D.down(function(){
                xpos+=speed*Math.cos(camera.rotation.y); 
                zpos-=speed*Math.sin(camera.rotation.y);
            });
            // next ones are for testing purposes
            kd.R.down(function(){
                ypos+=speed;
            });
            kd.F.down(function(){
                ypos-=speed;
            })
//            kd.UP.down(function(){
//                rot_y = 2;
//            })
//            kd.DOWN.down(function(){
//                rot_y = -2;
//            })
            kd.RIGHT.down(function(){
                rot_x = 2;
            });
            kd.LEFT.down(function(){
                rot_x = -2;
            });
        }
        function create2Darr(rows){
            var arr =[];
            for(var i=0;i<rows;i++)
                arr[i] = [];
            return arr;
        }

    </script>
    </body>
<script src="/client/client.js"></script>
</html>
